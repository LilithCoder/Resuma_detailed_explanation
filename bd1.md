拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。

就类对象而言，相同类型的类对象是通过拷贝构造函数来完成整个复制过程的。

函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。

```
classname (const classname &obj) {
   // 构造函数的主体
   // 在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。
}
```

## 拷贝构造函数通常用于：
---

- 通过使用另一个同类型的对象来初始化新创建的对象
    ```
    CExample A(100);
    CExample B=A;
    ```
    当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。

- 当函数的参数为类的对象时
    1. A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。
    2. 然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A);
    3. 等g_fun()执行完后, 析构掉 C 对象。  

- 函数的返回值是类的对象
    1. 先会产生一个临时变量，就叫XXXX吧。
    2. 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);
    3. 在函数执行到最后先析构temp局部变量。
    4. 等g_fun()执行完后再析构掉XXXX对象。

## 默认的拷贝函数——即浅拷贝
---

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。这就是“默认拷贝构造函数”。

这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，但拷贝构造函数没有处理静态数据成员。

当数据成员中没有指针时，浅拷贝是可行的。一旦对象存在了动态成员，那么浅拷贝就会出问题了。

但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。也就是说这个指针现在指向的内存区域其内容程序员无法把握和控制，也可能非常容易造成内存泄漏。所以，这时，必须采用深拷贝。

## 深拷贝
---

在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间

此时rect1的p和rect2的p各自指向一段内存空间，但它们指向的空间具有相同的内容，这就是所谓的“深拷贝”。


## 深拷贝与浅拷贝的区别
---

深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。


## 拷贝构造函数必须是引用传递，不能是值传递，这是为了防止递归引用。
---

当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参； 而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归。

## 防止默认拷贝发生
---

通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——声明一个私有拷贝构造函数。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。