### 内联函数和宏的区别
---

- 宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率。

    内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。如果内联函数的函数体过大，编译器会自动的把这个内联函数变成普通函数。

- 宏是由预处理器对宏进行替代

    而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。 

- 宏定义是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换

    内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，将函数体直接展开到调用处。这样可以省去函数的调用的开销，提高效率

- 宏定义是没有类型检查的，无论对还是错都是直接替换

    内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

- 宏定义和内联函数使用的时候都是进行代码展开。不同的是宏定义是在预编译的时候把所有的宏名替换
    
    内联函数则是在编译阶段在所有调用内联函数的地方把内联函数插入。这样可以省去函数压栈退栈，提高了效率

- 内联函数在运行时可调试
    
    而宏定义不可以

所有在类的声明中定义的函数将被自动认为是内联函数。

如果想将一个全局函数定义为内联函数可用，inline 关键字。

### 内联函数和普通函数的区别
---

- 内联函数和普通函数的参数传递机制相同，但是编译器会在每处调用内联函数的地方将内联函数内容展开，这样既避免了函数调用的开销又没有宏机制的缺陷

- 普通函数在被调用的时候，系统首先要到函数的入口地址去执行函数体，执行完成之后再回到函数调用的地方继续执行，函数始终只有一个复制。

- 内联函数不需要寻址，当执行到内联函数的时候，将此函数展开，如果程序中有N次调用了内联函数则会有N次展开函数代码

- 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句。如果内联函数函数体过于复杂，编译器将自动把内联函数当成普通函数来执行
