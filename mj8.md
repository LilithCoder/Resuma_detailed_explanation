## 什么引起线程切换
- 时间片轮转
- 线程阻塞
- 线程主动放弃时间片

### 直接开销
线程切换只能在内核态完成，如果当前用户处于用户态，则必然引起用户态与内核态的切换。

### 上下文切换
前面说线程（或者叫做进程都随意）信息需要用一个task_struct保存，线程切换时，必然需要将旧线程的task_struct从内核切出，将新线程的切入，带来上下文切换。除此之外，还需要切换寄存器、程序计数器、线程栈（包括操作栈、数据栈）等。

### 线程调度算法
线程调度算法需要管理线程的状态、等待条件等，如果根据优先级调度，则还需要维护优先级队列。如果线程切换比较频繁，该成本不容小觑。


## 上下文切换
内核为每一个进程维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。包括一下内容：
- 通用目的寄存器
- 浮点寄存器
- 程序计数器
- 用户栈
- 状态寄存器
- 内核栈
- 各种内核数据结构：比如描绘地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

## 进程切换
系统中的每个程序都是运行在某个进程的上下文中的。

上下文是由程序正确运行所需的状态组成的，这个状态包括存放在存储器中的程序的代码和数据，他的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。

所以进程切换就是上下文切换。

每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。

## 进程切换和线程切换的区别
最主要的一个区别在于进程切换涉及虚拟地址空间的切换而线程不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程

因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB

当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢