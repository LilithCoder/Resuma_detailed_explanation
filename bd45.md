volatile是一个变量修饰符，而synchronized是一个方法或块的修饰符。

## **使用volatile修饰的变量具有可见性**
---

可见性就是说一旦某个线程修改了volatile关键字修饰的变量，则该变量将会立即保存修改后的值到物理内存中，其他线程读取该变量时，也可以立即获取修改后的值。

在java运行中，为了提高程序的运行效率，对于一些变量的操作通常是在寄存器或者cpu缓存上进行的，之后才会保存到物理内存中，而使用volatile关键字修饰的变量则是直接读取物理内存。

volatile不能保证操作原子性

Java有一种主内存的机制，使用一个主内存来保存变量当前的正确的值。线程将变量的值拷贝到自己独立的内存中，而这些线程的内存拷贝可能与主内存中的值不同。

一个volatile类型的变量不允许线程从主内存中将变量的值拷贝到自己的存储空间。因此，一个声明为volatile类型的变量将在所有的线程中同步的获得数据，不论你在任何线程中更改了变量，其他的线程将立即得到同样的结果。由于线程存取或更改自己的数据拷贝有更高的效率，所以volatile类型变量在性能上有所消耗。

## **synchronized**
---

synchronized获取和释放由监听器控制的锁，如果两个线程都使用一个监听器(即相同对象锁)，那么监听器可以强制在一个时刻只有一个线程能处理代码块，这是最一般的同步。

另外，synchronized还能使内存同步。在实际当中，synchronized使得所有的线程内存与主内存相同步。

## **区别**
---

- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的

- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性

- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

## **应用场景**
---

volatile可以修饰变量，共享变量。

Synchronized的修辞范围为：

- 修饰一个代码块

- 修饰一个方法

- 修饰一个类

- 修饰一个静态的方法
