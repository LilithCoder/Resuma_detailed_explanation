在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。

所谓的锁，说白了就是内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功；如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。

### os是通过什么手段来保证锁操作本身的原子性的呢？
---

能不能让硬件做一种加锁的原子操作呢？ 大名鼎鼎的“test and set”指令就是做这个事情的，该指令将读取内存、判断和设置值作为一个原子操作。单核环境下，锁的操作肯定是原子性了，多核呢？貌似还是不行，因为多个核心他们的锁操作是没有干扰的，都能够同时执行“test and set”，还是会出现两个线程同时获取到锁的情况， 所以硬件提供了锁内存总线的机制，在锁内存总线的状态下执行“test and set”操作就可以保证一个只有一个核执行成功，也就保证了不会存在多线程获取到锁的情况。

### 硬件上怎么实现的
---

cpu会通过对总线加锁的手段来解决多核同时获取锁的情况，它到时是怎么实现的呢？ 在cpu芯片上有一个HLOCK Pin，可以通过发送指令来操作，将#HLOCK Pin电位拉低，并持续到这条指令执行完毕，从而将总线锁住，这样同一总线上的其他CPU就不能通过总线来访问内存了。最开始这些功能是用来测试cpu的，后来被操作系统实现而封装成各种功能：关键代码段，信号量等。

### 小结
---

在硬件层面，cpu提供了原子操作、锁内存总线等机制，OS根据这几个cpu硬件机制就能够实现锁，在基于锁，就能实现各种各样的同步机制（信号量、消息等等），要理解os提供的各种同步手段，需要先理解os是怎么实现锁的。