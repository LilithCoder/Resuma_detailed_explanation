C++的多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。

就是程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数，表现为多态。

在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数

### **C++ 多态的实现原理**
---

- 当类中存在虚函数时，编译器会在类中自动生成一个虚函数表

- 虚函数表是一个存储类成员函数指针的数据结构

- 虚函数表由编译器自动生成和维护

- virtual 修饰的成员函数会被编译器放入虚函数表中

- 存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）

```
#include <iostream>
 
using namespace std;
 
class Parent
{
public:
    // 父类虚函数必须要有 virtual 关键字
    virtual void fun()
    {
        cout << "父类" << endl;
    }
};
 
class Child : public Parent
{
public:
    // 子类有没有 virtual 关键字都可以
    void fun()
    {
        cout << "子类" << endl;
    }
};
 
int main()
{
    Parent *p = NULL; // 创建一个父类的指针
    Parent parent;
    Child child;
    p = &parent; // 指向父类的对象
    p->fun(); // 执行的是父类的 fun() 函数
    p = &child; // 指向子类的对象
    p->fun(); // 执行的是子类的 fun() 函数
    return 0;
}
```

- 父类的 fun() 是个虚函数，所以编译器给父类对象自动添加了一个 vptr 指针，指向父类的虚函数表，这个虚函数表里存放了父类的 fun() 函数的函数指针

- 子类的 fun() 函数是重写了父类的，即写不写 virtual 编译器都会为其自动添加一个 virtual，然后编译器给子类对象自动添加了一个 vptr 指针，指向子类的虚函数表，这个虚函数表里存放了子类的 fun() 函数的函数指针

- 执行 p->fun() 时，编译器检测到 fun() 是一个虚函数，所以不会静态的将 Parent 类的 fun() 方法直接编译过来，而是是运行的时候，动态的根据 base 指向的对象，找到这个对象的 vptr 指针，然后找到这个对象的虚函数表，最后调用虚函数表里对应的函数，实现多态

**虚函数** 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或后期绑定。